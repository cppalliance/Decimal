////
Copyright 2024 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#Benchmarks]
= Benchmarks
:idprefix: benchmarks_

This section describes a range of performance benchmarks that have been run comparing this library with the standard library, and how to run your own benchmarks if required.

The values in the ratio column are how many times longer running a specific operation takes in comparison to the same operation with a `double`.

IMPORTANT: On nearly all platforms there is hardware support for binary floating point math, so we are comparing hardware to software runtimes; *Decimal will be slower*

== How to run the Benchmarks
[#run_benchmarks_]

To run the benchmarks yourself, navigate to the test folder and define `BOOST_DECIMAL_RUN_BENCHMARKS` when running the tests.
An example on Linux with b2: `../../../b2 cxxstd=20 toolset=gcc-13 define=BOOST_DECIMAL_RUN_BENCHMARKS benchmarks -a release` .

== Comparisons

The benchmark for comparisons generates a random vector containing 20,000,000 elements and does operations `>`, `>=`, `<`, `\<=`, `==`, and `!=` between `vec[i] and vec[i + 1]`.
This is repeated 5 times to generate stable results.

=== x64 Linux Results

Run using an Intel i9-11900k chipset running RHEL 9.4 and GCC 11.4.1-3

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 35,581
| 0.604
| `double`
| 58,848
| 1.000
| `decimal32`
| 2,410,084
| 40.954
| `decimal64`
| 4,233,175
| 71.934
| `decimal128`
| 6,337,447
| 107.692
| `decimal32_fast`
| 628,241
| 10.676
| `decimal64_fast`
| 724,474
| 12.311
| `decimal128_fast`
| 517,930
| 8.801
| GCC `_Decimal32`
| 893,375
| 15.181
| GCC `_Decimal64`
| 496,127
| 8.431
| GCC `_Decimal128`
| 1,143,636
| 19.434
|===

=== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew Clang 18.1.8

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 131,803
| 2.060
| `double`
| 63,981
| 1.000
| `decimal32`
| 2,052,770
| 32.084
| `decimal64`
| 2,701,290
| 42.220
| `decimal128`
| 5,545,490
| 86.674
| `decimal32_fast`
| 728,146
| 11.381
| `decimal64_fast`
| 611,866
| 9.563
| `decimal128_fast`
| 714,586
| 11.169
|===

== Basic Operations

The benchmark for these operations generates a random vector containing 20,000,000 elements and does operations `+`, `-`, `*`, `/` between `vec[i] and vec[i + 1]`.
This is repeated 5 times to generate stable results.

=== x64 Linux Results

Run using an Intel i9-11900k chipset running RHEL 9.4 and GCC 11.4.1-3

==== Addition

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 54,566
| 1.077
| `double`
| 50,640
| 1.000
| `decimal32`
| 3,639,957
| 71.879
| `decimal64`
| 4,172,318
| 82.392
| `decimal128`
| 10,936,595
| 215.968
| `decimal32_fast`
| 1,148,249
| 22.675
| `decimal64_fast`
| 1,149,203
| 22.694
| `decimal128_fast`
| 7,424,598
| 146.615
| GCC `_Decimal32`
| 2,997,658
| 50.939
| GCC `_Decimal64`
| 2,129,898
| 36.193
| GCC `_Decimal128`
| 3,056,979
| 51.947
|===

==== Subtraction

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 48,654
| 0.912
| `double`
| 53,348
| 1.000
| `decimal32`
| 2,850,709
| 53.436
| `decimal64`
| 3,493,936
| 65.493
| `decimal128`
| 10,492,728
| 196.685
| `decimal32_fast`
| 1,012,199
| 18.974
| `decimal64_fast`
| 1,055,476
| 19.785
| `decimal128_fast`
| 2,114,185
| 39.630
| GCC `_Decimal32`
| 2,006,964
| 37.620
| GCC `_Decimal64`
| 1,324,796
| 24.833
| GCC `_Decimal128`
| 2,783,553
| 52.177
|===

==== Multiplication

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 53,405
| 1.101
| `double`
| 48,497
| 1.000
| `decimal32`
| 2,708,779
| 55.855
| `decimal64`
| 2,761,465
| 56.941
| `decimal128`
| 8,509,678
| 175.468
| `decimal32_fast`
| 451,679
| 9.313
| `decimal64_fast`
| 777,927
| 16.041
| `decimal128_fast`
| 13,970,509
| 288.070
| GCC `_Decimal32`
| 2,507,998
| 51.714
| GCC `_Decimal64`
| 2,414,864
| 49.794
| GCC `_Decimal128`
| 6,248,956
| 128.852
|===

==== Division

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 58,955
| 0.755
| `double`
| 78,046
| 1.000
| `decimal32`
| 2,907,134
| 37.249
| `decimal64`
| 3,464,841
| 44.394
| `decimal128`
| 18,202,742
| 233.231
| `decimal32_fast`
| 1,092,346
| 13.996
| `decimal64_fast`
| 1,207,648
| 15.474
| `decimal128_fast`
| 1,208,184
| 15.480
| GCC `_Decimal32`
| 5,002,197
| 64.093
| GCC `_Decimal64`
| 2,961,731
| 37.900
| GCC `_Decimal128`
| 10,095,995
| 129.360
|===

=== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 14.4.1 and homebrew Clang 18.1.4

==== Addition

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 43,056
| 1.295
| `double`
| 33,238
| 1.000
| `decimal32`
| 3,146,032
| 94.652
| `decimal64`
| 2,963,788
| 89.169
| `decimal128`
| 10,125,221
| 304.628
| `decimal32_fast`
| 1,685,360
| 50.706
| `decimal64_fast`
| 1,886,022
| 56.743
| `decimal128_fast`
| 6,893,049
| 207.385
|===

==== Subtraction

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 43,013
| 1.295
| `double`
| 33,204
| 1.000
| `decimal32`
| 2,385,896
| 71.586
| `decimal64`
| 2,759,536
| 83.108
| `decimal128`
| 5,560,295
| 167.459
| `decimal32_fast`
| 1,228,630
| 37.002
| `decimal64_fast`
| 1,312,815
| 39.538
| `decimal128_fast`
| 2,869,005
| 86.405
|===

==== Multiplication

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 42,634
| 1.293
| `double`
| 32,970
| 1.000
| `decimal32`
| 2,826,351
| 85.725
| `decimal64`
| 3,268,243
| 99.128
| `decimal128`
| 4,654,643
| 141.178
| `decimal32_fast`
| 1,614,365
| 48.965
| `decimal64_fast`
| 2,417,646
| 73.329
| `decimal128_fast`
| 8,017,934
| 243.189
|===

As discussed in the design of the fast types the significand is stored in normalized form so that we do not have to worry about the effects of cohorts.
Unfortunately this means that `decimal128_fast` multiplication is always carried out internally at 256-bit size whereas `decimal128` contains heuristics in `operator*` to avoid 256-bit multiplication when it is not needed (i.e. the resultant significand is less than or equal to 128-bits).
This causes multiplication of `decimal128_fast` to be ~1.72x slower than `decimal128`, but all other operators leave us with a geometric average runtime under 1.00 for `decimal128_fast` / `decimal128` so we accept this tradeoff.

==== Division

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 46,030
| 1.351
| `double`
| 34,078
| 1.000
| `decimal32`
| 2,649,922
| 77.760
| `decimal64`
| 3,721,028
| 109.192
| `decimal128`
| 19,559,739
| 573.970
| `decimal32_fast`
| 1,436,099
| 42.142
| `decimal64_fast`
| 2,593,573
| 76.107
| `decimal128_fast`
| 2,594,426
| 76.132
|===

== `<charconv>`

Parsing and serializing number exactly is one of the key features of decimal floating point types, so we must compare the performance of `<charconv>`. For all the following the results compare against STL provided `<charconv>` for 20,000,000 conversions.
Since `<charconv>` is fully implemented in software for each type the performance gap between built-in `float` and `double` vs `decimal32` and `decimal64` is significantly smaller (or the decimal performance is better) than the hardware vs software performance gap seen above for basic operations.

To run these benchmarks yourself you will need a compiler with complete implementation of `<charconv>` and to run the benchmarks under C++17 or higher.
At the time of writing this is limited to:

- GCC 11 or newer
- MSVC 19.24 or newer

These benchmarks are automatically disabled if your compiler does not provide feature complete `<charconv>` or if the language standard is set to C++14.

=== `from_chars`

==== `from_chars` general

===== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew GCC 14.2.0

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 2,556,533
| 0.965
| `double`
| 2,648,485
| 1.000
| `decimal32`
| 3,201,545
| 1.209
| `decimal64`
| 4,775,487
| 1.803
| `decimal32_fast`
| 3,196,724
| 1.207
| `decimal64_fast`
| 4,762,636
| 1.798
|===

==== `from_chars` scientific

===== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew GCC 14.2.0

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 2,651,707
| 0.986
| `double`
| 2,690,166
| 1.000
| `decimal32`
| 3,153,821
| 1.172
| `decimal64`
| 4,726,009
| 1.926
| `decimal32_fast`
| 4,726,009
| 1.757
| `decimal64_fast`
| 4,693,387
| 1.747
|===

=== `to_chars`

==== `to_chars` general shortest representation

===== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew GCC 14.2.0

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 2,917,920
| 0.849
| `double`
| 3,435,671
| 1.000
| `decimal32`
| 4,636,747
| 1.350
| `decimal64`
| 5,680,800
| 1.653
| `decimal32_fast`
| 4,675,951
| 1.361
| `decimal64_fast`
| 5,900,272
| 1.717
|===

==== `to_chars` general 6-digits of precision

===== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew GCC 14.2.0

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 6,320,719
| 0.962
| `double`
| 6,572,846
| 1.000
| `decimal32`
| 4,133,466
| 0.629
| `decimal64`
| 6,106,989
| 0.929
| `decimal32_fast`
| 3,458,534
| 0.526
| `decimal64_fast`
| 5,997,442
| 0.912
|===

==== `to_chars` scientific shortest representation

===== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew GCC 14.2.0

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 2,814,527
| 0.817
| `double`
| 3,442,930
| 1.000
| `decimal32`
| 3,048,663
| 0.885
| `decimal64`
| 3,786,216
| 1.010
| `decimal32_fast`
| 2,813,360
| 0.817
| `decimal64_fast`
| 4,082,146
| 1.186
|===

==== `to_chars` scientific 6-digits of precision

===== M1 macOS Results

Run using a Macbook pro with M1 pro chipset running macOS Sonoma 15.0 and homebrew GCC 14.2.0

|===
| Type | Runtime (us) | Ratio to `double`
| `float`
| 5,636,010
| 0.952
| `double`
| 5,922,301
| 1.000
| `decimal32`
| 3,048,058
| 0.515
| `decimal64`
| 5,140,604
| 0.868
| `decimal32_fast`
| 2,821,707
| 0.476
| `decimal64_fast`
| 5,525,549
| 0.933
|===
