////
Copyright 2024 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#conversions]
= Bit Conversions
:idprefix: conversions_

IEEE 754 specifies two different encodings for decimal floating point types: Binary Integer Significand Field (BID), and Densely Packed Decimal Significand Field (DPD).
Internally this library is implemented in the BID format for the IEEE-754 compliant types.
Should the user want to capture the bit format in BID or convert to DPD we offer a family of conversion functions: `to_bid`, `from_bid`, `to_dpd`, and `from_dpd` that allow conversion to or from the bit strings regardless of encoding.

[source, c++]
----
namespace boost {
namespace decimal {

namespace detail {

struct uint128
{
    std::uint64_t hi;
    std::uint64_t lo;
};

} // namespace detail

// ----- BID Conversions -----

constexpr std::uint32_t to_bid_d32(decimal32 val) noexcept;

constexpr decimal32 from_bid_d32(std::uint32_t bits) noexcept;

constexpr std::uint32_t to_bid_d32f(decimal32_fast val) noexcept;

constexpr decimal32_fast from_bid_d32f(std::uint32_t bits) noexcept;

constexpr std::uint64_t to_bid_d64(decimal64 val) noexcept;

constexpr decimal64 from_bid_d64(std::uint64_t bits) noexcept;

constexpr std::uint64_t to_bid_d64f(decimal64_fast val) noexcept;

constexpr decimal64_fast from_bid_d64f(std::uint64_t bits) noexcept;

constexpr detail::uint128 to_bid_d128(decimal128 val) noexcept;

constexpr decimal128 from_bid_d128(detail::uint128 bits) noexcept;

// Automatic detection if your platform has built-in unsigned __int128 or not to enable/disable the overload
#ifdef BOOST_DECIMAL_HAS_INT128

constexpr decimal128 from_bid_d128(unsigned __int128 bits) noexcept;

#endif // BOOST_DECIMAL_HAS_INT128

constexpr detail::uint128 to_bid_d128f(decimal128_fast val) noexcept;

constexpr decimal128 from_bid_d128f(detail::uint128 bits) noexcept;

#ifdef BOOST_DECIMAL_HAS_INT128

constexpr decimal128 from_bid_d128f(unsigned __int128 bits) noexcept;

#endif // BOOST_DECIMAL_HAS_INT128

template <typename T>
constexpr auto to_bid(T val) noexcept;

template <typename T = decimal32_fast>
constexpr T from_bid(std::uint32_t bits) noexcept;

template <typename T = decimal64_fast>
constexpr T from_bid(std::uint64_t bits) noexcept;

template <typename T = decimal128>
constexpr T from_bid(detail::uint128 bits) noexcept;

// ----- DPD Conversions -----

constexpr std::uint32_t to_dpd_d32(decimal32 val) noexcept;

constexpr std::uint32_t to_dpd_d32f(decimal32_fast val) noexcept;

constexpr std::uint64_t to_dpd_d64(decimal64 val) noexcept;

constexpr std::uint64_t to_dpd_d64f(decimal64_fast val) noexcept;

constexpr detail::uint128 to_dpd_d128(decimal128 val) noexcept;

constexpr detail::uint128 to_dpd_d128f(decimal128_fast val) noexcept;

template <typename T>
constexpr auto to_dpd(T val) noexcept;

template <typename T = decimal32_fast>
constexpr T from_dpd(std::uint32_t bits) noexcept;

template <typename T = decimal64_fast>
constexpr T from_dpd(std::uint64_t bits) noexcept;

template <typename T = decimal128_fast>
constexpr T from_dpd(detail::uint128 bits) noexcept;

#ifdef BOOST_DECIMAL_HAS_INT128
template <typename T = decimal128_fast>
constexpr T from_dpd(unsigned __int128 bits) noexcept;
#endif

} // namespace decimal
} // namespace boost
----

Example
[source, c++]
----
#include <boost/decimal.hpp>
#include <iostream>
#include <iomanip>

using namespace boost::decimal;

int main()
{
    const decimal32_fast fast_type {5};
    const std::uint32_t BID_bits {to_bid(fast_type)};
    const std::uint32_t DPD_bits {to_dpd(fast_type)};

    std::cout << std::hex
              << "BID format: " << BID_bits << '\n'
              << "DPD format: " << DPD_bits << std::endl;

    const decimal32 bid_decimal {from_bid<decimal32>(BID_bits)};
    const decimal32 dpd_decimal {from_dpd<decimal32>(DPD_bits)};

    return !(bid_decimal == dpd_decimal);
}
----
Output:
----
BID format: 31fc4b40
DPD format: 35f00000
----
